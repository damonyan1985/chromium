// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/webui/new_tab_page/new_tab_page_handler.h"

#include "base/bind.h"
#include "base/strings/utf_string_conversions.h"
#include "chrome/browser/ntp_tiles/chrome_most_visited_sites_factory.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/search/chrome_colors/chrome_colors_factory.h"
#include "chrome/browser/search/chrome_colors/chrome_colors_service.h"
#include "chrome/browser/search/instant_service.h"
#include "chrome/browser/search/instant_service_factory.h"
#include "chrome/browser/search_engines/template_url_service_factory.h"
#include "chrome/common/pref_names.h"
#include "chrome/common/search/generated_colors_info.h"
#include "chrome/common/search/instant_types.h"
#include "chrome/common/themes/autogenerated_theme_util.h"
#include "components/prefs/pref_service.h"
#include "ui/base/l10n/l10n_util.h"

namespace {

new_tab_page::mojom::ThemePtr MakeTheme(const NtpTheme& ntp_theme) {
  auto theme = new_tab_page::mojom::Theme::New();
  if (ntp_theme.color_id == -1) {
    theme->type = ntp_theme.using_default_theme
                      ? new_tab_page::mojom::ThemeType::DEFAULT
                      : new_tab_page::mojom::ThemeType::THIRD_PARTY;
  } else if (ntp_theme.color_id == 0) {
    theme->type = new_tab_page::mojom::ThemeType::AUTOGENERATED;
    auto theme_colors = new_tab_page::mojom::ThemeColors::New();
    theme_colors->frame = ntp_theme.color_dark;
    theme_colors->active_tab = ntp_theme.color_light;
    theme->info = new_tab_page::mojom::ThemeInfo::NewAutogeneratedThemeColors(
        std::move(theme_colors));
  } else {
    theme->type = new_tab_page::mojom::ThemeType::CHROME;
    theme->info =
        new_tab_page::mojom::ThemeInfo::NewChromeThemeId(ntp_theme.color_id);
  }
  return theme;
}

}  // namespace

NewTabPageHandler::NewTabPageHandler(
    mojo::PendingReceiver<new_tab_page::mojom::PageHandler>
        pending_page_handler,
    mojo::PendingRemote<new_tab_page::mojom::Page> pending_page,
    Profile* profile)
    : chrome_colors_service_(
          chrome_colors::ChromeColorsFactory::GetForProfile(profile)),
      page_{std::move(pending_page)},
      pref_service_(profile->GetPrefs()),
      receiver_{this, std::move(pending_page_handler)} {
  most_visited_sites_ = ChromeMostVisitedSitesFactory::NewForProfile(profile);
  // 9 tiles are required for the custom links feature in order to balance the
  // Most Visited rows (this is due to an additional "Add" button).
  most_visited_sites_->SetMostVisitedURLsObserver(this, 9);
  TemplateURLService* template_url_service =
      TemplateURLServiceFactory::GetForProfile(profile);
  if (template_url_service) {
    search_provider_observer_ = std::make_unique<SearchProviderObserver>(
        template_url_service,
        base::BindRepeating(&NewTabPageHandler::OnCustomLinksEnableChange,
                            weak_ptr_factory_.GetWeakPtr()));
  }
  most_visited_sites_->EnableCustomLinks(
      !pref_service_->GetBoolean(prefs::kNtpUseMostVisitedTiles));
  pref_change_registrar_.Init(pref_service_);
  pref_change_registrar_.Add(
      prefs::kNtpShortcutsVisible,
      base::BindRepeating(&NewTabPageHandler::OnNtpShortcutsVisibleChange,
                          weak_ptr_factory_.GetWeakPtr()));
  pref_change_registrar_.Add(
      prefs::kNtpUseMostVisitedTiles,
      base::BindRepeating(&NewTabPageHandler::OnCustomLinksEnableChange,
                          weak_ptr_factory_.GetWeakPtr()));

  instant_service_ = InstantServiceFactory::GetForProfile(profile);
  DCHECK(instant_service_);
  instant_service_->AddObserver(this);
}

NewTabPageHandler::~NewTabPageHandler() {
  instant_service_->RemoveObserver(this);
}

void NewTabPageHandler::AddMostVisitedTile(
    const GURL& url,
    const std::string& title,
    AddMostVisitedTileCallback callback) {
  bool success =
      most_visited_sites_->AddCustomLink(url, base::UTF8ToUTF16(title));
  std::move(callback).Run(success);
}

void NewTabPageHandler::DeleteMostVisitedTile(
    const GURL& url,
    DeleteMostVisitedTileCallback callback) {
  bool success = true;
  if (IsCustomLinksEnabled()) {
    success = most_visited_sites_->DeleteCustomLink(url);
  } else {
    most_visited_sites_->AddOrRemoveBlacklistedUrl(url, true);
    last_blacklisted_ = url;
  }
  std::move(callback).Run(success);
}

bool NewTabPageHandler::IsCustomLinksEnabled() {
  return search_provider_observer_ && search_provider_observer_->is_google() &&
         !pref_service_->GetBoolean(prefs::kNtpUseMostVisitedTiles);
}

void NewTabPageHandler::RestoreMostVisitedDefaults() {
  if (IsCustomLinksEnabled()) {
    most_visited_sites_->UninitializeCustomLinks();
  } else {
    most_visited_sites_->ClearBlacklistedUrls();
  }
}

void NewTabPageHandler::ReorderMostVisitedTile(const GURL& url,
                                               uint8_t new_pos) {
  most_visited_sites_->ReorderCustomLink(url, new_pos);
}

void NewTabPageHandler::UpdateMostVisitedTile(
    const GURL& url,
    const GURL& new_url,
    const std::string& new_title,
    UpdateMostVisitedTileCallback callback) {
  bool success = most_visited_sites_->UpdateCustomLink(
      url, new_url != url ? new_url : GURL(), base::UTF8ToUTF16(new_title));
  std::move(callback).Run(success);
}

void NewTabPageHandler::UndoMostVisitedTileAction() {
  if (IsCustomLinksEnabled()) {
    most_visited_sites_->UndoCustomLinkAction();
  } else if (last_blacklisted_.is_valid()) {
    most_visited_sites_->AddOrRemoveBlacklistedUrl(last_blacklisted_, false);
    last_blacklisted_ = GURL();
  }
}

void NewTabPageHandler::GetCustomizeInfo(GetCustomizeInfoCallback callback) {
  std::vector<new_tab_page::mojom::ChromeThemePtr> themes;
  for (const auto& color_info : chrome_colors::kGeneratedColorsInfo) {
    auto theme_colors = GetAutogeneratedThemeColors(color_info.color);
    auto theme = new_tab_page::mojom::ChromeTheme::New();
    theme->id = color_info.id;
    theme->label = l10n_util::GetStringUTF8(color_info.label_id);
    auto colors = new_tab_page::mojom::ThemeColors::New();
    colors->frame = theme_colors.frame_color;
    colors->active_tab = theme_colors.active_tab_color;
    theme->colors = std::move(colors);
    themes.push_back(std::move(theme));
  }
  auto info = new_tab_page::mojom::CustomizeInfo::New();
  info->current_theme = MakeTheme(*instant_service_->GetInitializedNtpTheme());
  info->chrome_themes = std::move(themes);
  std::move(callback).Run(std::move(info));
}

void NewTabPageHandler::ApplyDefaultTheme() {
  chrome_colors_service_->ApplyDefaultTheme(web_contents());
}

void NewTabPageHandler::ApplyAutogeneratedTheme(const SkColor& frame_color) {
  chrome_colors_service_->ApplyAutogeneratedTheme(frame_color, web_contents());
}

void NewTabPageHandler::ApplyChromeTheme(int32_t id) {
  auto* begin = std::begin(chrome_colors::kGeneratedColorsInfo);
  auto* end = std::end(chrome_colors::kGeneratedColorsInfo);
  auto* result = std::find_if(begin, end,
                              [id](const chrome_colors::ColorInfo& color_info) {
                                return color_info.id == id;
                              });
  if (result == end) {
    return;
  }
  chrome_colors_service_->ApplyAutogeneratedTheme(result->color,
                                                  web_contents());
}

void NewTabPageHandler::ConfirmThemeChanges() {
  chrome_colors_service_->ConfirmThemeChanges();
}

void NewTabPageHandler::RevertThemeChanges() {
  chrome_colors_service_->RevertThemeChanges();
}

void NewTabPageHandler::OnCustomLinksEnableChange() {
  most_visited_sites_->EnableCustomLinks(IsCustomLinksEnabled());
  page_->SetCustomLinksEnabled(IsCustomLinksEnabled());
}

void NewTabPageHandler::OnNtpShortcutsVisibleChange() {
  page_->SetMostVisitedVisible(
      pref_service_->GetBoolean(prefs::kNtpShortcutsVisible));
}

void NewTabPageHandler::OnURLsAvailable(
    const std::map<ntp_tiles::SectionType, ntp_tiles::NTPTilesVector>&
        sections) {
  DCHECK(most_visited_sites_);
  std::vector<new_tab_page::mojom::MostVisitedTilePtr> list;
  auto info = new_tab_page::mojom::MostVisitedInfo::New();
  info->visible = pref_service_->GetBoolean(prefs::kNtpShortcutsVisible);
  // Use only personalized tiles for instant service.
  const ntp_tiles::NTPTilesVector& tiles =
      sections.at(ntp_tiles::SectionType::PERSONALIZED);
  for (const ntp_tiles::NTPTile& tile : tiles) {
    auto value = new_tab_page::mojom::MostVisitedTile::New();
    value->title = base::UTF16ToUTF8(tile.title);
    value->url = tile.url;
    list.push_back(std::move(value));
  }
  info->custom_links_enabled =
      !pref_service_->GetBoolean(prefs::kNtpUseMostVisitedTiles);
  info->tiles = std::move(list);
  page_->SetMostVisitedInfo(std::move(info));
}

void NewTabPageHandler::NtpThemeChanged(const NtpTheme& ntp_theme) {
  page_->SetTheme(MakeTheme(ntp_theme));
}

void NewTabPageHandler::MostVisitedInfoChanged(const InstantMostVisitedInfo&) {
  // TODO(aee): Use this hook instead of registering our own pref listeners.
}
