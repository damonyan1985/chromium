#!/usr/bin/env python
# Copyright 2019 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
'''python %(prog)s [options]
Generate mapping from IPP attribute name to appropriate handler based on its
type as described in IPP registration files.'''

import argparse
import csv
import re

# We skip attributes that are already implemented in print preview.
NOOP_ATTRS = [
    'copies', 'job-hold-until', 'job-password', 'job-password-encryption',
    'media', 'media-col', 'number-up', 'page-ranges', 'print-color-mode',
    'printer-resolution', 'sheet-collate', 'sides'
]

# As defined by RFC 8011 (5.1.4).
KEYWORD_PATTERN = re.compile('^[a-z][a-z0-9\._-]*$')

OUTPUT_HEADER = """// DO NOT MODIFY
// Generated by printing/backend/tools/code_generator.py

#include "printing/backend/ipp_handler_map.h"

#include "base/bind.h"
#include "printing/backend/ipp_handlers.h"

namespace printing {

HandlerMap GenerateHandlers() {
  HandlerMap result;
"""

OUTPUT_FOOTER = """  return result;
}

}  // namespace printing
"""


def get_handler(syntax, name):
  if syntax.startswith('1setOf'):
    handler = get_handler(syntax[6:].strip(), name)
    if handler == 'EnumHandler':
      # 3 is 'none' value for finishings.
      # IPP enums always use positive numbers so we can use 0 in other cases.
      default = 3 if name.endswith('finishings') else 0
      return 'MultivalueEnumHandler, %d' % default

    # TODO(crbug.com/964919): Add other multivalue handlers.
    return ''

  if syntax == 'collection':
    # TODO(crbug.com/964919): Add collection handler.
    return ''

  if syntax.startswith('type1') or syntax.startswith('type2'):
    # ignore prefix
    return get_handler(syntax[5:].strip(), name)

  if syntax.startswith('keyword'):
    return 'KeywordHandler'

  if syntax.startswith('enum'):
    return 'EnumHandler'

  if syntax == 'boolean':
    return 'BooleanHandler'

  if syntax.startswith('integer'):
    # TODO(crbug.com/964919): Add integer handler.
    return 'NumberHandler'

  if syntax.startswith('name') or syntax.startswith('text'):
    return 'TextHandler'

  return ''


def main():
  parser = argparse.ArgumentParser(usage=__doc__)
  parser.add_argument(
      '-i',
      '--attributes-file',
      dest='attributes_file',
      help='path to ipp-registrations-2.csv input file',
      metavar='FILE',
      required=True)
  parser.add_argument(
      '-o',
      '--ipp-handler-map',
      dest='ipp_handler_map',
      help='path to ipp_handler_map.cc output file',
      metavar='FILE',
      required=True)
  args = parser.parse_args()

  with open(args.ipp_handler_map, 'w') as mapfile, \
       open(args.attributes_file, 'r') as attrfile:
    reader = csv.reader(attrfile)
    mapfile.write(OUTPUT_HEADER)

    for attr in reader:
      # Filter out by attribute group.
      if attr[0] not in ['Job Template', 'Operation']:
        continue

      # Skip sub-attributes.
      if attr[2] != '':
        continue

      attr_name = attr[1]
      # Remove annotations like '(obsolete)', '(deprecated)' etc.
      parenthesis = attr_name.find('(')
      if parenthesis != -1:
        attr_name = attr_name[:parenthesis].strip()

      if not KEYWORD_PATTERN.match(attr_name):
        print('Warning: attribute name %s is invalid' % attr_name)
        continue

      syntax = attr[4]
      handler = 'NoOpHandler'
      if attr_name not in NOOP_ATTRS:
        handler = get_handler(syntax.strip(), attr_name)

      if handler == '':
        continue

      mapfile.write('  result.emplace("%s", base::BindRepeating(&%s));\n' %
                    (attr_name, handler))

    mapfile.write(OUTPUT_FOOTER)


if __name__ == '__main__':
  main()
